<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js vr - panorama with depth</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
  </head>
  <body>
    <div id="container"></div>
    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three/build/three.module.js",
          "three/addons/": "https://unpkg.com/three/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";

      import { VRButton } from "three/addons/webxr/VRButton.js";

      import { RGBELoader } from "three/addons/loaders/RGBELoader.js";

      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";
      import { PMREMGenerator } from "/node_modules/three/src/extras/PMREMGenerator.js";
      // import { PMREMCubeUVPacker } from "/node_modules/three/src/extras/PMREMCubeUVPacker.js";

      // Create the Three.js scene, camera, and renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create VR button and add it to the HTML document
      document.body.appendChild(VRButton.createButton(renderer));

      // Create PMREMGenerator and PMREMCubeUVPacker for texture mapping
      const pmremGenerator = new PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();
      //const pmremCubeUVPacker = new PMREMCubeUVPacker(pmremGenerator.cubeLods);

      // Load the initial panoramic image
      const loader = new RGBELoader();
      loader.setDataType(THREE.HalfFloatType);
      loader.load("models/kirjasto(1).jpg", function (texture) {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        const envMap = pmremGenerator.fromEquirectangular(texture).texture;
        scene.background = envMap;
        scene.environment = envMap;
        texture.dispose();
        pmremGenerator.dispose();
      });

      // Load the second panoramic image
      loader.setDataType(THREE.FloatType);
      loader.load("models/kirjasto(2).jpg", function (texture) {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        const envMap = pmremGenerator.fromEquirectangular(texture).texture;
        const cubeMap = envMap;
        cubeMap.encoding = THREE.sRGBEncoding;
        scene.background = cubeMap;
        scene.environment = cubeMap;
        texture.dispose();
        pmremGenerator.dispose();
        // pmremCubeUVPacker.dispose();
      });

      // Create a VR controller object and add it to the scene
      const controller = renderer.xr.getController(0);
      controller.addEventListener("select", onSelect);
      scene.add(controller);

      // Create a sphere geometry and add it to the scene
      const geometry = new THREE.SphereGeometry(500, 60, 40);
      const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
      material.side = THREE.BackSide;
      const sphere = new THREE.Mesh(geometry, material);
      scene.add(sphere);

      // Set the initial camera position
      camera.position.set(0, 0, 0.1);

      // Function to handle VR controller button clicks
      function onSelect() {
        // Remove the previous image from the scene
        sphere.material.dispose();
        sphere.geometry.dispose();
        scene.remove(sphere);

        // Load the next panoramic image
        loader.load("models/kirjasto(3).jpg", function (texture) {
          texture.mapping = THREE.EquirectangularReflectionMapping;
          const envMap = pmremGenerator.fromEquirectangular(texture).texture;
          //const cubeMap = pmremCubeUVPacker.pack(envMap);
          cubeMap.encoding = THREE.sRGBEncoding;
          // Set the texture of the sphere to the new panoramic image
          sphere.material.map = texture;
          sphere.material.needsUpdate = true;

          // Set the texture of the environment to the new panoramic image
          scene.background = cubeMap;

          // Render the new scene
          renderer.render(scene, camera);
        });

        // Function to handle the VR controller button click
        function onVRControllerClick(event) {
          // Load the next panoramic image when the button is clicked
          if (event.target === controller1 || event.target === controller2) {
            // Load the next panoramic image
            loader.load("models/kirjasto(3).jpg", function (texture) {
              texture.mapping = THREE.EquirectangularReflectionMapping;
              const envMap =
                pmremGenerator.fromEquirectangular(texture).texture;
              // const cubeMap = pmremCubeUVPacker.pack(envMap);
              cubeMap.encoding = THREE.sRGBEncoding;

              // Set the texture of the sphere to the new panoramic image
              sphere.material.map = texture;
              sphere.material.needsUpdate = true;

              // Set the texture of the environment to the new panoramic image
              scene.background = cubeMap;

              // Render the new scene
              renderer.render(scene, camera);
            });
          }
        }

        // Event listener for the VR controller button click
        window.addEventListener("vrcontrollerdown", onVRControllerClick);

        // Event listener for the VR controller button click
        function onControllerButtonClicked(event) {
          if (event.detail.state === "clicked") {
            // Load the next panoramic image
            loader.load("models/kirjasto(3).jpg", function (texture) {
              texture.mapping = THREE.EquirectangularReflectionMapping;
              const envMap =
                pmremGenerator.fromEquirectangular(texture).texture;
              //const cubeMap = pmremCubeUVPacker.pack(envMap);
              cubeMap.encoding = THREE.sRGBEncoding;

              // Update the material with the new texture
              material.envMap = cubeMap;
              material.needsUpdate = true;

              // Dispose of the old texture and cube map
              texture2.dispose();
              pmremGenerator.dispose();
              // pmremCubeUVPacker.dispose();

              // Update the current texture
              texture2 = cubeMap;
            });
          }
        }

        // Add the event listener to the VR controller
        controller.addEventListener("buttondown", onControllerButtonClicked);

        // Render function to update the scene
        function render() {
          renderer.render(scene, camera);
        }

        // Update function to handle VR controller input
        function update() {
          // Get the VR controller input
          const input = renderer.vr.getController(0).getButtonState("trigger");

          // If the input is clicked
          if (input.pressed) {
            // Load the next panoramic image
            loader.load("models/kirjasto(3).jpg", function (texture) {
              texture.mapping = THREE.EquirectangularReflectionMapping;
              const envMap =
                pmremGenerator.fromEquirectangular(texture).texture;
              //const cubeMap = pmremCubeUVPacker.pack(envMap);
              cubeMap.encoding = THREE.sRGBEncoding;

              // Update the scene with the new texture
              scene.environment = cubeMap;
              scene.background = cubeMap;

              // Dispose of the old texture
              texture1.dispose();
              texture2.dispose();

              // Set the new texture as the current texture
              texture2 = cubeMap;

              // Render the updated scene
              render();
            });
          }
        }

        // Start the render loop
        function animate() {
          renderer.setAnimationLoop(() => {
            update();
          });
        }

        // Call the animate function to start the render loop
        animate();
      }
    </script>
  </body>
</html>
