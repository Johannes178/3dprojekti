<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js vr - panorama with depth</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
  </head>
  <body>
    <div id="container"></div>
    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three/build/three.module.js",
          "three/addons/": "https://unpkg.com/three/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      import { VRButton } from "three/addons/webxr/VRButton.js";

      import { RGBELoader } from "three/addons/loaders/RGBELoader.js";

      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";

      let camera,
        scene,
        renderer,
        sphere,
        clock,
        controller1,
        controller2,
        controllerGrip1,
        controllerGrip2,
        raycaster;
      const intersected = [];
      const tempMatrix = new THREE.Matrix4();
      let group;

      init();

      function init() {
        const container = document.getElementById("container");
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101010);
        const light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        scene.add(camera);

        // Create the panoramic sphere geometery
        const panoSphereGeo = new THREE.SphereGeometry(6, 256, 256);

        // Create the panoramic sphere material
        const panoSphereMat = new THREE.MeshStandardMaterial({
          side: THREE.BackSide,
          displacementScale: -4.0,
        });

        // Create the panoramic sphere mesh
        sphere = new THREE.Mesh(panoSphereGeo, panoSphereMat);

        // Load and assign the texture and depth map
        const manager = new THREE.LoadingManager();

        const loader = new THREE.TextureLoader(manager);
        loader.load("models/kirjasto(1).jpg", function (texture) {
          texture.minFilter = THREE.NearestFilter;
          texture.generateMipmaps = false;
          sphere.material.map = texture;
        });
        const loader1 = new THREE.TextureLoader(manager);
        loader.load("models/kirjasto(2).jpg", function (texture) {
          texture.minFilter = THREE.NearestFilter;
          texture.generateMipmaps = false;
          sphere.material.map = texture;
        });
        //depth

        /*loader.load("models/kirjasto(1).jpg", function (depth) {
                      depth.minFilter = THREE.NearestFilter;
                      depth.generateMipmaps = false;
                      sphere.material.displacementMap = depth;
                    });*/

        // On load complete add the panoramic sphere to the scene
        manager.onLoad = function () {
          scene.add(sphere);
        };

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType("local");
        container.appendChild(renderer.domElement);

        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        renderer.toneMapping = THREE.LinearToneMapping;
        renderer.outputEncoding = THREE.sRGBEncoding;

        const controls = new OrbitControls(camera, renderer.domElement);

        controls.minDistance = 1;
        controls.maxDistance = 50;

        camera.position.z = 5;
        camera.position.y = 2;
        camera.position.x = 2;
        controls.update();

        initVR();

        function initVR() {
          document.body.appendChild(VRButton.createButton(renderer));
          renderer.xr.enabled = true;

          // controllers

          controller1 = renderer.xr.getController(0);
          controller1.addEventListener("selectstart", onSelectStart);
          controller1.addEventListener("selectend", onSelectEnd);
          scene.add(controller1);

          controller2 = renderer.xr.getController(1);
          controller2.addEventListener("selectstart", onSelectStart);
          controller2.addEventListener("selectend", onSelectEnd);
          scene.add(controller2);

          const controllerModelFactory = new XRControllerModelFactory();

          controllerGrip1 = renderer.xr.getControllerGrip(0);
          controllerGrip1.add(
            controllerModelFactory.createControllerModel(controllerGrip1)
          );
          scene.add(controllerGrip1);

          // controllerGrip2 = renderer.xr.getControllerGrip( 1 );
          // controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
          // scene.add( controllerGrip2 );

          raycaster = new THREE.Raycaster();

          scene.add(controllerGrip1);
          scene.add(controllerGrip2);
          const axesHelper = new THREE.AxesHelper(5);
          scene.add(axesHelper);

          camera.lookAt(axesHelper.position);
          //
        }
      }
      function onSelectStart(event) {
        const controller = event.target;

        const intersections = getIntersections(controller);

        if (intersections.length > 0) {
        }
      }

      function onSelectEnd(event) {
        const controller = event.target;

        controller.userData.selected = undefined;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      renderer.setAnimationLoop(function () {
        renderer.render(scene, camera);
      });

      function render() {
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>

To implement the transition between the two textures when pressing a button in
VR, you can modify the onSelectStart function that is called when a controller
button is pressed. <br />
First, you need to declare a variable to store the current texture index, for
example: <br />
let currentTextureIndex = 0; <br />
Then, inside the onSelectStart function, you can check if the button that was
pressed is the one you want to use for the texture transition, for example:
<br />
function onSelectStart(event) { if
(event.inputSource.gamepad.buttons[0].pressed) { // change texture
currentTextureIndex = (currentTextureIndex + 1) % 2; // toggle between 0 and 1
const loader = new THREE.TextureLoader(manager);
loader.load(`models/kirjasto(${currentTextureIndex + 1}).jpg`, function
(texture) { texture.minFilter = THREE.NearestFilter; texture.generateMipmaps =
false; sphere.material.map = texture; }); } } <br />
In this example, we assume that you want to use the first button of the
controller to trigger the texture transition. The currentTextureIndex variable
is used to keep track of the current texture. We toggle between texture 1 and
texture 2 by incrementing the index and taking the modulus with 2. Then, we
create a new texture loader and load the appropriate texture based on the
current index. Finally, we set the loaded texture as the material map of the
sphere. Note that you need to declare the currentTextureIndex variable outside
the init function and make it available to the onSelectStart function. Also note
that you should use loader1.load for the second texture, instead of loader.load,
which was used for the first texture in the original code.
