<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js vr - panorama with depth</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
  </head>
  <body>
    <div id="container"></div>
    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three/build/three.module.js",
          "three/addons/": "https://unpkg.com/three/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      import { VRButton } from "three/addons/webxr/VRButton.js";

      import { RGBELoader } from "three/addons/loaders/RGBELoader.js";

      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";

      let camera,
        scene,
        renderer,
        sphere,
        clock,
        controller1,
        controller2,
        raycaster;
      const intersected = [];
      const tempMatrix = new THREE.Matrix4();
      let group;

      init();

      function init() {
        group = new THREE.Group();
        const container = document.getElementById("container");
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101010);
        const light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        scene.add(camera);

        // Create the panoramic sphere geometery
        const panoSphereGeo = new THREE.SphereGeometry(6, 256, 256);

        // Create the panoramic sphere material
        const panoSphereMat = new THREE.MeshStandardMaterial({
          side: THREE.BackSide,
          displacementScale: -4.0,
        });

        // Create the panoramic sphere mesh
        sphere = new THREE.Mesh(panoSphereGeo, panoSphereMat);

        // Load and assign the textures and depth maps
        const manager = new THREE.LoadingManager();

        const loader1 = new THREE.TextureLoader(manager);
        loader1.load("models/kirjasto(1).jpg", function (texture1) {
          texture1.minFilter = THREE.NearestFilter;
          texture1.generateMipmaps = false;
          const sphereMaterial1 = new THREE.MeshStandardMaterial({
            map: texture1,
            side: THREE.BackSide,
            displacementScale: -4.0,
          });
          const sphere1 = new THREE.Mesh(panoSphereGeo, sphereMaterial1);
          sphere1.position.set(0, 0, 0);
          scene.add(sphere1);
        });

        const loader2 = new THREE.TextureLoader(manager);
        loader2.load("models/kirjasto(2).jpg", function (texture2) {
          texture2.minFilter = THREE.NearestFilter;
          texture2.generateMipmaps = false;
          const sphereMaterial2 = new THREE.MeshStandardMaterial({
            map: texture2,
            side: THREE.BackSide,
            displacementScale: -4.0,
          });
          const sphere2 = new THREE.Mesh(panoSphereGeo, sphereMaterial2);
          sphere2.position.set(0, 0, -20);
          scene.add(sphere2);
        });
        // On load complete add the panoramic sphere to the scene
        manager.onLoad = function () {
          scene.add(sphere);
        };

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType("local");
        container.appendChild(renderer.domElement);

        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        renderer.toneMapping = THREE.LinearToneMapping;
        renderer.outputEncoding = THREE.sRGBEncoding;

        const controls = new OrbitControls(camera, renderer.domElement);

        controls.minDistance = 1;
        controls.maxDistance = 50;

        camera.position.z = 5;
        camera.position.y = 2;
        camera.position.x = 2;
        controls.update();
        document.body.appendChild(VRButton.createButton(renderer));

        initVR();

        function initVR() {
          renderer.xr.enabled = true;

          // controllers

          controller1 = renderer.xr.getController(0);
          controller1.addEventListener("selectstart", onSelectStart);
          scene.add(controller1);

          controller2 = renderer.xr.getController(1);
          controller2.addEventListener("selectstart", onSelectStart);
          scene.add(controller2);

          const controllerModelFactory = new XRControllerModelFactory();

          raycaster = new THREE.Raycaster();
          const axesHelper = new THREE.AxesHelper(5);
          scene.add(axesHelper);

          camera.lookAt(axesHelper.position);
          //
        }
      }
      function onSelectStart(event) {
        console.log("onSelectStart called");

        const controller = event.target;
        const intersections = getIntersections(controller);

        if (intersections.length > 0) {
          const intersection = intersections[0];
          const object = intersection.object;

          if (object.name === "sphere1") {
            renderer.xr.setReferenceSpaceType("local");
            sphere.visible = false;
            group.visible = true;
            group.children[0].visible = true;
            group.children[1].visible = false;
            controller.userData.selected = group.children[0];
          } else if (object.name === "sphere2") {
            renderer.xr.setReferenceSpaceType("local");
            sphere.visible = false;
            group.visible = true;
            group.children[0].visible = false;
            group.children[1].visible = true;
            controller.userData.selected = group.children[1];
          }
        }
      }

      function getIntersections(controller) {
        console.log("intersect called");

        return raycaster.intersectObjects(group.children);
      }

      function animate() {
        renderer.setAnimationLoop(render);
      }

      function render() {
        // Handle controller interactions
        intersected.forEach((object) => {
          object.rotation.x;
          object.rotation.y;
        });

        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>

const loader3 = new THREE.TextureLoader(manager);
loader3.load("models/kirjasto(3).jpg", function (texture3) { texture3.minFilter
= THREE.NearestFilter; texture3.generateMipmaps = false; const sphereMaterial3 =
new THREE.MeshStandardMaterial({ map: texture3, side: THREE.BackSide,
displacementScale: -4.0, }); const sphere3 = new THREE.Mesh(panoSphereGeo,
sphereMaterial3); sphere3.position.set(0, 0, -40); scene.add(sphere3); }); const
loader4 = new THREE.TextureLoader(manager);
loader4.load("models/kirjasto(4).jpg", function (texture4) { texture4.minFilter
= THREE.NearestFilter; texture4.generateMipmaps = false; const sphereMaterial4 =
new THREE.MeshStandardMaterial({ map: texture4, side: THREE.BackSide,
displacementScale: -4.0, }); const sphere4 = new THREE.Mesh(panoSphereGeo,
sphereMaterial4); sphere4.position.set(0, 0, -60); scene.add(sphere4); }); const
loader5 = new THREE.TextureLoader(manager);
loader5.load("models/kirjasto(4).jpg", function (texture5) { texture5.minFilter
= THREE.NearestFilter; texture5.generateMipmaps = false; const sphereMaterial4 =
new THREE.MeshStandardMaterial({ map: texture5, side: THREE.BackSide,
displacementScale: -4.0, }); const sphere5 = new THREE.Mesh(panoSphereGeo,
sphereMaterial4); sphere5.position.set(0, 0, -80); scene.add(sphere5); });
